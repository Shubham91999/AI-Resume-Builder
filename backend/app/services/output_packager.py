"""
Output Packager â€” bundles all outputs into a named folder as ZIP.

Creates the folder structure:
  {Job Position} - {Company}/
  â”œâ”€â”€ FirstName_LastName_Resume.docx
  â”œâ”€â”€ FirstName_LastName_Resume.pdf  (if converter available)
  â”œâ”€â”€ cold_emails.docx               (both emails in one doc)
  â””â”€â”€ ats_analysis.txt                (before/after scores, breakdown, keywords)
"""

from __future__ import annotations

import io
import logging
import re
import zipfile
from typing import Optional

from docx import Document
from docx.shared import Pt

from app.models.email_models import EmailGenerateResponse
from app.models.jd_models import ParsedJD
from app.models.resume_models import ParsedResume
from app.models.score_models import ResumeScore, ScoreComparison
from app.models.tailor_models import TailoredResume
from app.services.ats_scorer import score_resume
from app.services.docx_builder import build_docx
from app.services.pdf_generator import docx_to_pdf, is_pdf_converter_available

logger = logging.getLogger(__name__)


def generate_ats_report(
    *,
    before_score: ResumeScore,
    after_score: ResumeScore,
    jd: ParsedJD,
    tailored: TailoredResume,
) -> str:
    """
    Generate a human-readable ATS analysis report.

    Shows before/after scores, breakdown, knockout alerts, and keywords added.
    """
    improvement = after_score.overall_score - before_score.overall_score
    lines = [
        "=" * 60,
        "ATS Analysis Report",
        f"Generated by AI Resume Tailor",
        "=" * 60,
        "",
        f"Job Title:  {jd.job_title}",
        f"Company:    {jd.company}",
        f"JD Type:    {jd.jd_type}",
        "",
        "-" * 60,
        "OVERALL SCORE COMPARISON",
        "-" * 60,
        f"  Before Tailoring:  {before_score.overall_score:.1f}%",
        f"  After Tailoring:   {after_score.overall_score:.1f}%",
        f"  Improvement:       {'+' if improvement >= 0 else ''}{improvement:.1f}%",
        "",
        "-" * 60,
        "SCORE BREAKDOWN",
        "-" * 60,
        f"  {'Component':<30} {'Before':>8} {'After':>8} {'Change':>8}",
        f"  {'â”€' * 30} {'â”€' * 8} {'â”€' * 8} {'â”€' * 8}",
    ]

    components = [
        ("Required Skills", before_score.breakdown.required_skills_pct, after_score.breakdown.required_skills_pct),
        ("Preferred Skills", before_score.breakdown.preferred_skills_pct, after_score.breakdown.preferred_skills_pct),
        ("Title Similarity", before_score.breakdown.title_similarity_pct, after_score.breakdown.title_similarity_pct),
        ("Experience Relevance", before_score.breakdown.experience_relevance_pct, after_score.breakdown.experience_relevance_pct),
        ("Years Experience Fit", before_score.breakdown.years_experience_fit_pct, after_score.breakdown.years_experience_fit_pct),
        ("Education Match", before_score.breakdown.education_match_pct, after_score.breakdown.education_match_pct),
    ]

    for name, before, after in components:
        change = after - before
        sign = "+" if change >= 0 else ""
        lines.append(f"  {name:<30} {before:>7.1f}% {after:>7.1f}% {sign}{change:>6.1f}%")

    # Knockout alerts
    lines.extend(["", "-" * 60, "KNOCKOUT ALERTS (Before)", "-" * 60])
    if before_score.knockout_alerts:
        for alert in before_score.knockout_alerts:
            icon = "ðŸ”´" if alert.severity == "critical" else "âš ï¸"
            lines.append(f"  {icon} [{alert.severity.upper()}] {alert.message}")
    else:
        lines.append("  âœ… No knockout alerts")

    lines.extend(["", "-" * 60, "KNOCKOUT ALERTS (After)", "-" * 60])
    if after_score.knockout_alerts:
        for alert in after_score.knockout_alerts:
            icon = "ðŸ”´" if alert.severity == "critical" else "âš ï¸"
            lines.append(f"  {icon} [{alert.severity.upper()}] {alert.message}")
    else:
        lines.append("  âœ… No knockout alerts")

    # Skills added
    lines.extend(["", "-" * 60, "SKILLS CHANGES", "-" * 60])
    if tailored.skills_added:
        lines.append(f"  Added:   {', '.join(tailored.skills_added)}")
    if tailored.skills_removed:
        lines.append(f"  Removed: {', '.join(tailored.skills_removed)}")
    if not tailored.skills_added and not tailored.skills_removed:
        lines.append("  No changes")

    # Keyword coverage
    lines.extend([
        "",
        "-" * 60,
        "KEYWORD COVERAGE",
        "-" * 60,
        f"  Coverage: {tailored.keywords_coverage}%",
        f"  Keywords used: {', '.join(tailored.keywords_used[:20])}",
    ])

    lines.extend(["", "=" * 60, ""])
    return "\n".join(lines)


def build_score_comparison(
    *,
    before_score: ResumeScore,
    after_score: ResumeScore,
    tailored: TailoredResume,
) -> ScoreComparison:
    """Build a ScoreComparison model from before/after scores."""
    improvement = after_score.overall_score - before_score.overall_score
    return ScoreComparison(
        before=before_score,
        after=after_score,
        improvement_pct=round(improvement, 1),
        keywords_added=tailored.skills_added or [],
    )


def build_email_docx(emails: EmailGenerateResponse) -> io.BytesIO:
    """Build a single DOCX containing both cold emails."""
    doc = Document()

    # Style
    style = doc.styles["Normal"]
    font = style.font  # type: ignore[union-attr]
    font.name = "Calibri"
    font.size = Pt(11)

    # Recruiter email
    doc.add_heading("Cold Email â€” Recruiter", level=1)
    doc.add_heading(f"Subject: {emails.recruiter_email.subject}", level=2)
    doc.add_paragraph(emails.recruiter_email.body)

    doc.add_page_break()

    # Hiring Manager email
    doc.add_heading("Cold Email â€” Hiring Manager", level=1)
    doc.add_heading(f"Subject: {emails.hiring_manager_email.subject}", level=2)
    doc.add_paragraph(emails.hiring_manager_email.body)

    buffer = io.BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer


def package_outputs(
    *,
    tailored: TailoredResume,
    jd: ParsedJD,
    emails: Optional[EmailGenerateResponse],
    before_score: Optional[ResumeScore],
    after_score: Optional[ResumeScore],
) -> io.BytesIO:
    """
    Package all outputs into a single ZIP file with organized folder structure.

    Returns a BytesIO buffer containing the ZIP.
    """
    # Folder name: "{Job Position} - {Company}"
    folder = _safe_folder_name(jd.job_title, jd.company)
    safe_name = re.sub(r"[^\w]", "_", tailored.name)
    base_filename = f"{safe_name}_Resume"

    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
        # 1. Resume DOCX
        docx_buffer = build_docx(tailored)
        zf.writestr(f"{folder}/{base_filename}.docx", docx_buffer.read())

        # 2. Resume PDF (if converter available)
        if is_pdf_converter_available():
            try:
                docx_buffer.seek(0)
                pdf_buffer = docx_to_pdf(docx_buffer)
                zf.writestr(f"{folder}/{base_filename}.pdf", pdf_buffer.read())
            except Exception as e:
                logger.warning(f"PDF generation skipped: {e}")

        # 3. Cold emails DOCX
        if emails:
            email_docx = build_email_docx(emails)
            zf.writestr(f"{folder}/cold_emails.docx", email_docx.read())

        # 4. ATS analysis report
        if before_score and after_score:
            report = generate_ats_report(
                before_score=before_score,
                after_score=after_score,
                jd=jd,
                tailored=tailored,
            )
            zf.writestr(f"{folder}/ats_analysis.txt", report)

    zip_buffer.seek(0)
    return zip_buffer


def _safe_folder_name(job_title: str, company: str) -> str:
    """Build a safe folder name from job title and company."""
    raw = f"{job_title} - {company}" if company else job_title
    # Keep alphanumeric, spaces, hyphens, underscores
    safe = re.sub(r"[^\w\s\-]", "", raw).strip()
    return safe or "Resume_Output"
